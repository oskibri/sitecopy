#!/bin/bash
# Info: Sitecopy 2.0 | Copy site from any environment to Servebolt
# Date: 6th of October
# Author: Oskar Voldbakken Hesle
# Version 1.1.2
# Dependencies: getopt

pwd="$PWD"
trap "cd $pwd; ssh-agent -k &>/dev/null; tput cnorm; stty sane; rm -rf $HOME/tmp/exclude_list.txt 2>/dev/null" EXIT SIGINT
cd "$HOME" || exit 10

SSH_PRIVKEY="$HOME/.ssh/id_rsa"
SSH_PUBKEY="$HOME/.ssh/id_rsa.pub"

SSHUSER=
SSHHOST=
SSHPORT=22

LOCAL_DBNAME=
LOCAL_DBUSER=
LOCAL_DBHOST="localhost"
LOCAL_DBPASS=

REMOTE_DBNAME=
REMOTE_DBUSER=
REMOTE_DBHOST="localhost"
REMOTE_DBPASS=

NODB=
CONFIG_PATH=
CONFIG_FILE=
DOCUMENT_ROOT=

SOURCE_DIRECTORY=
DESTINATION_DIRECTORY="$HOME"
EXCLUDE_LIST=("sitecopy" "/.*" "/environment.*" "/.ssh/id_rsa*" "/logs" "/tmp" "/php-session" "/php-upload")

# Check NGL or legacy structure
if [[ $(awk -F/ '{print $2}' <<< "$PWD") == 'cust' ]]; then
  DESTINATION_DIRECTORY="$HOME/site/public"
  NGL="TRUE"
elif [[ $(awk -F/ '{print $2}' <<< "$PWD") == 'kunder' ]]; then
  DESTINATION_DIRECTORY="$HOME/public"
fi

usage() {
cat << EOF
$(printf "\033[1;32mInfo:\033[0m")
  Sitecopy. A script to copy one site to a Servebolt site. Excellent from fetching a site externally to setting up a staging site
  Simply provide the script with a remote user and host + the local database name and the script will try to resolve the rest
  More explicit options can also be set for finer control
$(printf "\033[1;32mUsage:\033[0m")
  bash $0 [OPTIONS] <USER@HOSTNAME> <LOCAL_DATABASE>
$(printf "\033[1;32mExample:\033[0m")
  #1: bash $0 boltuser_1234@servebolt.cloud localdb
  #2: bash $0 -u "boltuser_1234" -h "servebolt.cloud" "localdb" --port=1022 --exclude="*.jpg,path/to/exclude"
$(printf "\033[1;32mOptions:\033[0m")
      --help                    Show this
  -s, --src=<DIRECTORY>         Choose which directory sitecopy should copy the files from
                                  Default is remote SSH user's home directory
  -d, --dest=<DIRECTORY>        Choose which directory sitecopy should place the copied files to
                                  Default is $(if [[ -f "$HOME/environment.json" ]]; then jq -r .public_dir "$HOME/environment.json"; elif [[ -f "$HOME/environment.ini" ]]; then awk -F= '/public_dir/ {print $2}' "$HOME/environment.ini"; else [[ "$SERVER" == "cust" ]] && printf "~/site/public" || printf "~/public"; fi)
  -e, --exclude=<LIST>          Set a list of directories and/or files to exclude from the copy.
                                  List must be separated by commas (file1,file2,fileN)
  -D, --local-dbname=<NAME>     Set the local database name
  -P, --local-dbpass=<PASS>     Set the local database password. If not set, sitecopy will try to update the password (WIP)
  -u, --user=<REMOTE_USER>      Set the remote SSH username
  -h, --host=<REMOTE_HOST>      Set the remote SSH hostname
  -p, --port=<PORT_NUM>         Set the remote SSH port number. Default is '22'
      --remote-dbname=<NAME>    set the remote database name. If not set, sitecopy will try to find it in a remote config file
      --remote-dbuser=<USER>    Set the remote database user. If not set, sitecopy will try to find it in a remote config file
      --remote-dbhost=<HOST>    Set the remote database host. If not set, sitecopy will try to find it in a remote config file
      --remote-dbpass=<PASS>    Set the remote database pass. If not set, sitecopy will try to find it in a remote config file
  -o, --only-docroot            Enable to only transfer what is in remote document root and drop transfer of anything else
EOF
}

OPTS=$(getopt -n "$0" \
  -o s:d:e:u:h:p:D:P:o \
  -l help,src:,dest:,exclude:,user:,host:,port:,local-dbname:,local-dbpass:,remote-dbname:,remote-dbuser:,remote-dbhost:,remote-dbpass:,only-docroot -- "$@")
eval set -- "$OPTS"

while true; do
  case "$1" in
    --help)
      usage
      exit 0 ;;
    -s|--src)
      MANUAL_SOURCE="TRUE"
      SOURCE_DIRECTORY="$2"
      shift 2 ;;
    -d|--dest)
      DESTINATION_DIRECTORY="$2"
      shift 2 ;;
    -e|--exclude)
      CUSTOM_EXCLUDE_LIST=( $(tr ',' ' ' <<< "$2") )
      EXCLUDE_LIST+=( $(tr ',' ' ' <<< "$2") )
      shift 2 ;;
    -u|--user)
      SSHUSER="$2"
      shift 2 ;;
    -h|--host)
      SSHHOST="$2"
      shift 2 ;;
    -p|--port)
      SSHPORT="$2"
      shift 2 ;;
    -D|--local-dbname)
      LOCAL_DBNAME="$2"
      shift 2 ;;
    -P|--local-dbpass)
      LOCAL_DBPASS="$2"
      shift 2 ;;
    --remote-dbname)
      REMOTE_DBNAME="$2"
      shift 2 ;;
    --remote-dbuser)
      REMOTE_DBUSER="$2"
      shift 2 ;;
    --remote-dbhost)
      REMOTE_DBHOST="$2"
      shift 2 ;;
    --remote-dbpass)
      REMOTE_DBPASS="$2"
      shift 2 ;;
    -o|--only-docroot)
      ONLY_DOCROOT="TRUE"
      shift ;;
    --)
      shift 1
      while [[ "$@" ]]; do
        if [[ "$1" =~ ^[A-Za-z0-9_-]+@[A-Za-z0-9.-]+(:[0-9]{1,5})?$ ]]; then
          [[ ! "$SSHUSER" ]] && SSHUSER=$(awk -F'@'    '{print $1}' <<< "$1")
          [[ ! "$SSHHOST" ]] && SSHHOST=$(awk -F'[@:]' '{print $2}' <<< "$1")
          [[ ! "$SSHPORT" ]] && SSHPORT=$(awk -F':'    '{print $2}' <<< "$1")
        fi
        [[ "$1" =~ ^[A-Za-z0-9_\-]{1,64}$ ]] && LOCAL_DBNAME="$1"
        shift 1
      done
      break ;;
    *)
      printf "\033[1;31mError:\033[0m Alians, or russians. Only explanation\n" >&2
      exit 100 ;;
  esac
done

# Check that SSH user and host is set
if [[ ! "$SSHUSER" || ! "$SSHHOST" ]]; then
  printf "\033[1;31mError:\033[0m Remote SSH user and host must be set\n" >&2
  usage
  exit 1
# Check that local database name is set
elif [[ ! "$LOCAL_DBNAME" ]]; then
  printf "\033[1;33mWarning:\033[0m Local database name not set. Database transfer will be skipped\n" >&2
  NODB="TRUE"
fi

# Check for environment files
if [[ ! -f "$HOME/environment.json" && ! -f "$HOME/environment.ini" ]]; then
  printf "\033[1;33mWarning:\033[0m Check that either environment.json or environment.ini is available for better logic\n" >&2
else
  [[ -f "$HOME/environment.json" ]] && ENV_FILE="$HOME/environment.json" || ENV_FILE="$HOME/environment.ini"
fi
# ^^ TODO: Possible removal of check. Currently only usage is for changing DB password which isn't easy with current API setup.

# Check if normal SSH keys are present
if [[ ! -f "$HOME/.ssh/id_rsa" || ! -f "$HOME/.ssh/id_rsa.pub" ]]; then
  mkdir -p "$HOME/.ssh"
  eval "$(ssh-agent -s)" &>/dev/null
  ssh-keygen -qt rsa -N "" -f "$SSH_PRIVKEY" <<< 'y' &>/dev/null || exit 9
  chmod 700 "$SSH_PRIVKEY"
  chmod 700 "$SSH_PUBKEY"
  ssh-add "$SSH_PRIVKEY" &>/dev/null
fi

# Add SSH pub key to remote host if not done already
if ! ssh -qo PasswordAuthentication=no -i "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "exit" &>/dev/null; then
  echo "Please enter the remote SSH user password. This will only be asked once"
  ssh-copy-id -p "$SSHPORT" "$SSHUSER@$SSHHOST" &>/dev/null || exit 9
fi


getConfigFile() {
  local num=0
  local configArr=( $(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" \
    'find $HOME -type d -name "wp-content" -prune -o \
    \( -name "wp-config.php" -o -name ".env" -o -name "env.php" \) -print | sort -r') )
  local homeDir=$(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" 'echo $HOME')

  # If no config file found, return and don't transfer database
  [[ ! "${configArr[@]}" ]] && NODB="TRUE" && return 1

  # If more than one config file found, prompt the user for which to use
  if [[ "${#configArr[@]}" -gt 1 ]]; then
    printf "\033[1;32mInfo:\033[0m Found more than one remote config file\n\tPlease choose one of the following to set the CMS type with document root and/or getting remote DB credentials:\n"
    local index=
    for index in "${!configArr[@]}"; do
      printf "\033[1;32m%d\033[0m: \033[1;34m%s\033[0m\n" "$((index+1))" "${configArr[$index]/$homeDir\//}"
    done

    num=
    local configNum=${#configArr[@]}
    local configNumLength=${#configNum}
    printf "Enter number [\033[1;32m1\033[0m]: "
    local keyPress=
    while read -srn $configNumLength keyPress 2>/dev/null; do
      [[ ! $keyPress && ! $num ]] && num=1 && echo -n $num && break
      [[ ! $keyPress ]] && break
      [[ ! $keyPress =~ [0-9] ]] && continue
      [[ $keyPress -le $configNum && ! $keyPress -eq 0 ]] && num="$keyPress" && printf "%d\033[1D" "$num"
    done
    printf "\n"
    num=$((num-1))
  fi

  # Save directory name of config file and config file itself
  CONFIG_FILE=$(basename ${configArr[$num]})
  CONFIG_PATH=${configArr[$num]/"/$CONFIG_FILE"/}
}

parseConfig() {
  if [[ "$CONFIG_FILE" == 'wp-config.php' ]]; then
    local dbCredentialsArr=( $(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "\
      awk -F'[\042\047]' '/DB_NAME/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/DB_USER/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/DB_HOST/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/DB_PASSWORD/ {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE") )

    local index=
    for index in "${!dbCredentialsArr[@]}"; do
      [[ ${dbCredentialsArr[$index]} =~ DB_NAME ]] && \
        REMOTE_DBNAME=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]}) # | sed -E "s/^['\"](.*)['\"].*$/\1/")
      [[ ${dbCredentialsArr[$index]} =~ DB_USER ]] && \
        REMOTE_DBUSER=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]}) # | sed -E "s/^['\"](.*)['\"].*$/\1/")
      [[ ${dbCredentialsArr[$index]} =~ DB_HOST ]] && \
        REMOTE_DBHOST=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]}) # | sed -E "s/^['\"](.*)['\"].*$/\1/")
      [[ ${dbCredentialsArr[$index]} =~ DB_PASSWORD ]] && \
        REMOTE_DBPASS=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]}) # | sed -E "s/^['\"](.*)['\"].*$/\1/")
    done
  elif [[ "$CONFIG_FILE" == 'env.php' ]]; then
    local dbCredentialsArr=( $(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "\
      awk -F'[\042\047]' '/dbname/   {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/username/ {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/host/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/password/ {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE") )

    local index=
    for index in "${!dbCredentialsArr[@]}"; do
      [[ ${dbCredentialsArr[$index]} =~ ^dbname$ ]]   && REMOTE_DBNAME=${dbCredentialsArr[$index+1]}
      [[ ${dbCredentialsArr[$index]} =~ ^username$ ]] && REMOTE_DBUSER=${dbCredentialsArr[$index+1]}
      [[ ${dbCredentialsArr[$index]} =~ ^host$ ]]     && REMOTE_DBHOST=${dbCredentialsArr[$index+1]}
      [[ ${dbCredentialsArr[$index]} =~ ^password$ ]] && REMOTE_DBPASS=${dbCredentialsArr[$index+1]}
    done
  fi
}

checkRemoteDatabaseConnection() {
  if ! ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "export MYSQL_PWD='$REMOTE_DBPASS' && mysql -h$REMOTE_DBHOST -u$REMOTE_DBUSER $REMOTE_DBNAME -e 'exit' &>/dev/null"; then
    printf "\033[1;31mError:\033[0m Remote database connection failed. Try setting remote database credentials explicity\n" >&2
    NODB="TRUE"
  fi
}

setLocalDBPassword() {
  [[ "$NODB" ]] && return 1
  if [[ ! -f "$ENV_FILE" && ! "$LOCAL_DBPASS" ]]; then
    printf "\033[1;31mError:\033[0m No way to import database. Set local database password explicity, or enable environment files\n" >&2
    exit 2
  elif [[ ! "$LOCAL_DBPASS" ]]; then
    # local apiKey=$(awk -F'[=:]' '/api_key/ {print $2}' "$ENV_FILE" | tr -d ' ,"')
    # local envID=$(awk -F'[=:]' '/[^bolt_]id/ {print $2}' "$ENV_FILE" | tr -d ' ,"')
    # printf "\033[1;31mError:\033[0m Updating database password via API is not currently implemented.\nPlease enter local database password for \033[1;34m%s\033[0m: " "$LOCAL_DBNAME" >&2
    printf "Please enter local database password for \033[1;34m%s\033[0m: " "$LOCAL_DBNAME"
    read -s LOCAL_DBPASS
    echo
  fi
}
# ^^ TODO: Restructuring and removal of ENV file check. With current setup it will not be easy to change DB password with API key in environment.ini or json. 

checkLocalDatabaseConnection() {
  export MYSQL_PWD="$LOCAL_DBPASS"
  if ! mysql -u"$LOCAL_DBNAME" "$LOCAL_DBNAME" -e 'exit' &>/dev/null; then
    printf "\033[1;31mError:\033[0m Local database connection failed. Recheck you database credentials\n" >&2
    NODB="TRUE"
  fi
}

checkDocumentRoot() {
  local remoteHome=$(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" 'echo $HOME')

  if [[ "$CONFIG_FILE" == "wp-config.php" ]]; then
    local WPRootDirs=$(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "find $CONFIG_PATH -maxdepth 1 -type d \( -name "wp-includes" -o -name "wp-admin" \) -print 2>/dev/null" | wc -l)

    [[ ! "$WPRootDirs" -eq 2 ]] && printf "\033[1;33mWarning:\033[0m Remote document root couldn't be established because of non standard WP structure. Will copy everything as is to destination directory\n" >&2 && return 1

    DOCUMENT_ROOT="$CONFIG_PATH"
    LOCAL_CONFIG_PATH=${CONFIG_PATH/$remoteHome/}
  elif [[ "$CONFIG_FILE" == "env.php" ]]; then
    DOCUMENT_ROOT="$(sed -E 's%/app/etc$%%g' <<< $CONFIG_PATH)"
    LOCAL_CONFIG_PATH=${CONFIG_PATH/$remoteHome/}
  fi
}

transferFiles() {
  if [[ "$MANUAL_SOURCE" ]]; then
    rsync -ave "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/exclude_list.txt" "$SSHUSER@$SSHHOST:$SOURCE_DIRECTORY" "$DESTINATION_DIRECTORY" | pv -cli 0.1 -N"Files Transferred" >/dev/null &
  elif [[ "$DOCUMENT_ROOT" ]]; then
    # Rsync over the document root and place it in local document root
    rsync -ave "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/custom_exclude_list.txt" "$SSHUSER@$SSHHOST:$DOCUMENT_ROOT/" "$DESTINATION_DIRECTORY" | pv -cli 0.1 -N"Files Transferred" >/dev/null &
    # Rsync over non standard files and directories from remote user root
    [[ ! "$ONLY_DOCROOT" ]] && rsync -ae "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/exclude_list.txt" --exclude="/$(basename $DOCUMENT_ROOT)" "$SSHUSER@$SSHHOST:$SOURCE_DIRECTORY" "$HOME" >/dev/null &
  else
    rsync -ave "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/exclude_list.txt" "$SSHUSER@$SSHHOST:$SOURCE_DIRECTORY" "$DESTINATION_DIRECTORY" | pv -cli 0.1 -N"Files Transferred" >/dev/null &
  fi
}

transferDatabase() {
  export MYSQL_PWD="$LOCAL_DBPASS"
  ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "export MYSQL_PWD='$REMOTE_DBPASS' && mysqldump --single-transaction -u $REMOTE_DBUSER $REMOTE_DBNAME" | pv -ci 0.1 -N"Database Transfer" | sed 's/DEFINER=[^*]*\*/\*/g' | mysql -u "$LOCAL_DBNAME" "$LOCAL_DBNAME" &
}

updateLocalConfig() {
  if [[ "$DOCUMENT_ROOT" ]]; then
    REMOTE_DBPASS=$(sed -E 's/(\W)/\\\1/g' <<< $REMOTE_DBPASS)
    LOCAL_DBPASS=$(sed -E 's/(\W)/\\\1/g' <<< $LOCAL_DBPASS)

    [[ "$CONFIG_FILE" == 'env.php' ]] && DESTINATION_DIRECTORY="$DESTINATION_DIRECTORY/app/etc"

    perl -pi -E "s/$REMOTE_DBNAME/$LOCAL_DBNAME/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
    perl -pi -E "s/$REMOTE_DBUSER/$LOCAL_DBNAME/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
    perl -pi -E "s/$REMOTE_DBHOST/$LOCAL_DBHOST/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
    perl -pi -E "s/$REMOTE_DBPASS/$LOCAL_DBPASS/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
  else
    printf "\033[1;33mWarning:\033[0m Manual change of config file is needed if it exists\n" >&2
    return 1
  fi
}

# MAIN
mkdir -p "$HOME/tmp"
tr ' ' '\n' <<< "${EXCLUDE_LIST[@]}" > "$HOME/tmp/exclude_list.txt"
tr ' ' '\n' <<< "${CUSTOM_EXCLUDE_LIST[@]}" > "$HOME/tmp/custom_exclude_list.txt"

getConfigFile
[[ ! "$NODB" ]] && parseConfig
[[ ! "$NODB" ]] && checkRemoteDatabaseConnection
[[ ! "$NODB" ]] && setLocalDBPassword
[[ ! "$NODB" ]] && checkLocalDatabaseConnection
checkDocumentRoot

printf "\033[1;32mDoing Transfer...\033[0m\n"
tput civis
transferFiles
[[ ! "$NODB" ]] && transferDatabase
wait
tput cnorm

updateLocalConfig
tput bel
exit 0

