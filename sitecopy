#!/bin/bash
# Info: Sitecopy 2.0 | Copy site from any environment to Servebolt
# Date: 9th of November, 2023
# Author: Oskar Voldbakken Hesle
# Version 1.2.1
# Dependencies: getopt

pwd="$PWD"
interupt() {
  cd "$pwd"
  ssh-agent -k &>/dev/null
  tput cnorm
  rm -rf "$HOME"/tmp/{custom_,}exclude_list.txt 2>/dev/null
  stty sane
  echo
  exit 9
}
trap 'interupt' EXIT SIGINT
cd "$HOME" || exit 10

SSH_PRIVKEY="$HOME/.ssh/id_rsa"
SSH_PUBKEY="$HOME/.ssh/id_rsa.pub"

SSHUSER=
SSHHOST=
SSHPORT=22

LOCAL_DBNAME=
LOCAL_DBUSER=
LOCAL_DBHOST="localhost"
LOCAL_DBPASS=

REMOTE_DBNAME=
REMOTE_DBUSER=
REMOTE_DBHOST="localhost"
REMOTE_DBPASS=

NODB=
CONFIG_PATH=
CONFIG_FILE=
DOCUMENT_ROOT=

SOURCE_DIRECTORY=
DESTINATION_DIRECTORY="$HOME"
EXCLUDE_LIST=(/.{vim*,wp-cli,bash*,less*,local,mysql*} /environment.{json,ini} "/.ssh/id_rsa*" "/logs" "/tmp" "/php-session" "/php-upload")

# Check NGL or legacy structure
if [[ $(awk -F/ '{print $2}' <<< "$PWD") == 'cust' ]]; then
  DESTINATION_DIRECTORY="$HOME/site/public"
  NGL="TRUE"
elif [[ $(awk -F/ '{print $2}' <<< "$PWD") == 'kunder' ]]; then
  DESTINATION_DIRECTORY="$HOME/public"
fi

usage() {
cat << EOF
$(printf "\033[1;32mInfo:\033[0m")
  Sitecopy. A script to copy one site to a Servebolt site. Excellent from fetching a site externally to setting up a staging site
  Simply provide the script with a remote user and host + the local database name and the script will try to resolve the rest
  More explicit options can also be set for finer control
$(printf "\033[1;32mUsage:\033[0m")
  bash $0 [OPTIONS] <USER@HOSTNAME> <LOCAL_DATABASE>
$(printf "\033[1;32mExample:\033[0m")
  #1: bash $0 boltuser_1234@servebolt.cloud localdb
  #2: bash $0 -u "boltuser_1234" -h "servebolt.cloud" "localdb" --port=1022 --exclude="*.jpg,path/to/exclude"
$(printf "\033[1;32mOptions:\033[0m")
      --help                    Show this
  -s, --src=<DIRECTORY>         Choose which directory sitecopy should copy the files from
                                  Default is remote SSH user's home directory
  -d, --dest=<DIRECTORY>        Choose which directory sitecopy should place the copied files to
                                  Default is $(if [[ -f "$HOME/environment.json" ]]; then jq -r .public_dir "$HOME/environment.json"; elif [[ -f "$HOME/environment.ini" ]]; then awk -F= '/public_dir/ {print $2}' "$HOME/environment.ini"; else [[ "$SERVER" == "cust" ]] && printf "~/site/public" || printf "~/public"; fi)
  -e, --exclude=<LIST>          Set a list of directories and/or files to exclude from the copy.
                                  List must be separated by commas (file1,file2,fileN)
  -D, --local-dbname=<NAME>     Set the local database name
  -P, --local-dbpass=<PASS>     Set the local database password. If not set, sitecopy will try to update the password (WIP)
  -u, --user=<REMOTE_USER>      Set the remote SSH username
  -h, --host=<REMOTE_HOST>      Set the remote SSH hostname
  -p, --port=<PORT_NUM>         Set the remote SSH port number. Default is '22'
      --remote-dbname=<NAME>    set the remote database name. If not set, sitecopy will try to find it in a remote config file
      --remote-dbuser=<USER>    Set the remote database user. If not set, sitecopy will try to find it in a remote config file
      --remote-dbhost=<HOST>    Set the remote database host. If not set, sitecopy will try to find it in a remote config file
      --remote-dbpass=<PASS>    Set the remote database pass. If not set, sitecopy will try to find it in a remote config file
  -o, --only-docroot            Enable to only transfer what is in remote document root and drop transfer of anything else
EOF
}

OPTS=$(getopt -n "$0" \
  -o s:d:e:u:h:p:D:P:t:ko \
  -l help,src:,dest:,exclude:,user:,host:,port:,local-dbname:,local-dbpass:,remote-dbname:,remote-dbuser:,remote-dbhost:,remote-dbpass:,only-docroot,type:,key -- "$@")
eval set -- "$OPTS"

while true; do
  case "$1" in
    --help)
      usage
      exit 0 ;;
    -s|--src)
      MANUAL_SOURCE="TRUE"
      SOURCE_DIRECTORY="$2"
      shift 2 ;;
    -d|--dest)
      DESTINATION_DIRECTORY="$2"
      shift 2 ;;
    -e|--exclude)
      CUSTOM_EXCLUDE_LIST=( $(tr ',' ' ' <<< "$2") )
      EXCLUDE_LIST+=( $(tr ',' ' ' <<< "$2") )
      shift 2 ;;
    -u|--user)
      SSHUSER="$2"
      shift 2 ;;
    -h|--host)
      SSHHOST="$2"
      shift 2 ;;
    -P|--port)
      SSHPORT="$2"
      shift 2 ;;
    -D|--local-dbname)
      LOCAL_DBNAME="$2"
      shift 2 ;;
    -p|--local-dbpass)
      LOCAL_DBPASS="$2"
      shift 2 ;;
    --remote-dbname)
      REMOTE_DBNAME="$2"
      shift 2 ;;
    --remote-dbuser)
      REMOTE_DBUSER="$2"
      shift 2 ;;
    --remote-dbhost)
      REMOTE_DBHOST="$2"
      shift 2 ;;
    --remote-dbpass)
      REMOTE_DBPASS="$2"
      shift 2 ;;
    -o|--only-docroot)
      ONLY_DOCROOT="TRUE"
      shift ;;
    -t|--type)
      # For old sitecopy backwards compatibility
      shift 2 ;;
    -k|--key)
      # For old sitecopy backwards compatibility
      shift ;;
    --)
      shift 1
      while [[ "$@" ]]; do
        if [[ "$1" =~ ^[A-Za-z0-9_-]+@[A-Za-z0-9.-]+(:[0-9]{1,5})?$ ]]; then
          [[ ! "$SSHUSER" ]] && SSHUSER=$(awk -F'@'    '{print $1}' <<< "$1")
          [[ ! "$SSHHOST" ]] && SSHHOST=$(awk -F'[@:]' '{print $2}' <<< "$1")
          [[ ! "$SSHPORT" ]] && SSHPORT=$(awk -F':'    '{print $2}' <<< "$1")
        fi
        [[ "$1" =~ ^[A-Za-z0-9_\-]{1,64}$ ]] && LOCAL_DBNAME="$1"
        shift 1
      done
      break ;;
    *)
      printf "\033[1;31mError:\033[0m Alians, or russians. Only explanation\n" >&2
      exit 100 ;;
  esac
done

# Check that SSH user and host is set
if [[ ! "$SSHUSER" || ! "$SSHHOST" ]]; then
  printf "\033[1;31mError:\033[0m Remote SSH user and host must be set\n" >&2
  usage
  exit 1
# Check that local database name is set
elif [[ ! "$LOCAL_DBNAME" ]]; then
  printf "\033[1;33mWarning:\033[0m Local database name not set. Database transfer will be skipped\n" >&2
  NODB="TRUE"
fi

# Check if normal SSH keys are present
if [[ ! -f "$HOME/.ssh/id_rsa" || ! -f "$HOME/.ssh/id_rsa.pub" ]]; then
  mkdir -p "$HOME/.ssh"
  eval "$(ssh-agent -s)" &>/dev/null
  ssh-keygen -qt rsa -N "" -f "$SSH_PRIVKEY" <<< 'y' &>/dev/null || exit 9
  chmod 700 "$SSH_PRIVKEY"
  chmod 700 "$SSH_PUBKEY"
  ssh-add "$SSH_PRIVKEY" &>/dev/null
fi

# Check if SSH public key is added to remote host, otherwise add them with SSH password. Exit if port / credentials are wrong
if ! ssh -qo PasswordAuthentication=no -i "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "exit" &>/dev/null; then
  echo "Please enter the remote SSH user password. This will only be asked once"
  if ! ssh-copy-id -p "$SSHPORT" "$SSHUSER@$SSHHOST" &>/dev/null; then
    tput cuu1
    tput el
    printf "\033[1;31mError:\033[0m Likely wrong port number. Double check your SSH credentials. Exiting..."
    exit 9
  fi
fi


getConfigFile() {
  local num=0
  local configArr=( $(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" \
    'find $HOME -type d -name "wp-content" -prune -o \
    \( -name "wp-config.php" -o -name ".env" -o -name "env.php" \) -print | sort -r') )
  local homeDir=$(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" 'echo $HOME')

  # If no config file found, return and don't transfer database
  [[ ! "${configArr[@]}" ]] && NODB="TRUE" && return 1

  # If more than one config file found, prompt the user for which to use
  if [[ "${#configArr[@]}" -gt 1 ]]; then
    printf "\033[1;32mInfo:\033[0m Found more than one remote config file\nPlease choose one of the following to set the CMS type with document root and/or getting remote DB credentials:\n"
    local index=
    for index in "${!configArr[@]}"; do
      printf "\033[1;32m%d\033[0m: \033[1;34m%s\033[0m\n" "$((index+1))" "${configArr[$index]/$homeDir\//}"
    done

    num=
    local configNum=${#configArr[@]}
    local configNumLength=${#configNum}
    printf "Enter number [\033[1;32m1\033[0m]: "
    local keyPress=
    while read -srn $configNumLength keyPress 2>/dev/null; do
      [[ ! $keyPress && ! $num ]] && num=1 && echo -n $num && break
      [[ ! $keyPress ]] && break
      [[ ! $keyPress =~ [0-9] ]] && continue
      [[ $keyPress -le $configNum && ! $keyPress -eq 0 ]] && num="$keyPress" && printf "%d\033[1D" "$num"
    done
    printf "\n"
    num=$((num-1))
  fi

  # Save directory name of config file and config file itself
  CONFIG_FILE=$(basename ${configArr[$num]})
  CONFIG_PATH=${configArr[$num]/"/$CONFIG_FILE"/}
}

parseConfig() {
  if [[ "$CONFIG_FILE" == 'wp-config.php' ]]; then
    local dbCredentialsArr=( $(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "\
      awk -F'[\042\047]' '/DB_NAME/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/DB_USER/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/DB_HOST/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/DB_PASSWORD/ {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE") )

    local index=
    for index in "${!dbCredentialsArr[@]}"; do
      [[ ! $REMOTE_DBNAME && ${dbCredentialsArr[$index]} =~ DB_NAME ]] && \
        REMOTE_DBNAME=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]}) 
      [[ ! $REMOTE_DBUSER && ${dbCredentialsArr[$index]} =~ DB_USER ]] && \
        REMOTE_DBUSER=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]})
      [[ ! $REMOTE_DBHOST && ${dbCredentialsArr[$index]} =~ DB_HOST ]] && \
        REMOTE_DBHOST=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]})
      [[ ! $REMOTE_DBPASS && ${dbCredentialsArr[$index]} =~ DB_PASSWORD ]] && \
        REMOTE_DBPASS=$(tr -d ' ' <<< ${dbCredentialsArr[$index+1]})
    done
  elif [[ "$CONFIG_FILE" == 'env.php' ]]; then
    local dbCredentialsArr=( $(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "\
      awk -F'[\042\047]' '/dbname/   {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/username/ {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/host/     {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE; \
      awk -F'[\042\047]' '/password/ {print \$2, \$4}' $CONFIG_PATH/$CONFIG_FILE") )

    local index=
    for index in "${!dbCredentialsArr[@]}"; do
      [[ ! $REMOTE_DBNAME && ${dbCredentialsArr[$index]} =~ ^dbname$ ]]   && REMOTE_DBNAME=${dbCredentialsArr[$index+1]}
      [[ ! $REMOTE_DBUSER && ${dbCredentialsArr[$index]} =~ ^username$ ]] && REMOTE_DBUSER=${dbCredentialsArr[$index+1]}
      [[ ! $REMOTE_DBHOST && ${dbCredentialsArr[$index]} =~ ^host$ ]]     && REMOTE_DBHOST=${dbCredentialsArr[$index+1]}
      [[ ! $REMOTE_DBPASS && ${dbCredentialsArr[$index]} =~ ^password$ ]] && REMOTE_DBPASS=${dbCredentialsArr[$index+1]}
    done
  fi
}

checkRemoteDatabaseConnection() {
  if ! ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "export MYSQL_PWD='$REMOTE_DBPASS' && mysql -h$REMOTE_DBHOST -u$REMOTE_DBUSER $REMOTE_DBNAME -e 'exit' &>/dev/null"; then
    printf "\033[1;31mError:\033[0m Remote database connection failed. Double check your remote DB credentials or set them explicitly\n" >&2
    NODB="TRUE"
  fi
}

setLocalDBPassword() {
  [[ "$NODB" ]] && return 1
  if [[ ! "$LOCAL_DBPASS" ]]; then
    printf "Please enter local database password for \033[1;34m%s\033[0m. Password will not be shown: " "$LOCAL_DBNAME"
    read -s LOCAL_DBPASS || exit 
    echo
  fi
}

checkLocalDatabaseConnection() {
  export MYSQL_PWD="$LOCAL_DBPASS"
  if ! mysql -u"$LOCAL_DBNAME" "$LOCAL_DBNAME" -e 'exit' &>/dev/null; then
    printf "\033[1;31mError:\033[0m Local database connection failed. Recheck you database credentials\n" >&2
    NODB="TRUE"
  fi
}

checkDocumentRoot() {
  local remoteHome=$(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" 'echo $HOME')

  if [[ "$CONFIG_FILE" == "wp-config.php" ]]; then
    local WPRootDirs=$(ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "find $CONFIG_PATH -maxdepth 1 -type d \( -name "wp-includes" -o -name "wp-admin" \) -print 2>/dev/null" | wc -l)

    [[ ! "$WPRootDirs" -eq 2 ]] && printf "\033[1;33mWarning:\033[0m Remote document root couldn't be established because of non standard WP structure\nWill copy everything as is to destination directory\n" >&2 && return 1

    DOCUMENT_ROOT="$CONFIG_PATH"
    LOCAL_CONFIG_PATH=${CONFIG_PATH/$remoteHome/}
  elif [[ "$CONFIG_FILE" == "env.php" ]]; then
    DOCUMENT_ROOT="$(sed -E 's%/app/etc$%%g' <<< $CONFIG_PATH)"
    LOCAL_CONFIG_PATH=${CONFIG_PATH/$remoteHome/}
  fi
}

transferFiles() {
  if [[ "$MANUAL_SOURCE" ]]; then
    rsync -ave "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/exclude_list.txt" "$SSHUSER@$SSHHOST:$SOURCE_DIRECTORY" "$DESTINATION_DIRECTORY" | pv -cli 0.1 -N"Files Transferred" >/dev/null &
  elif [[ "$DOCUMENT_ROOT" ]]; then
    # Rsync over the document root and place it in local document root
    rsync -ave "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/custom_exclude_list.txt" "$SSHUSER@$SSHHOST:$DOCUMENT_ROOT/" "$DESTINATION_DIRECTORY" | pv -cli 0.1 -N"Files Transferred" >/dev/null &
    # Rsync over non standard files and directories from remote user root
    [[ ! "$ONLY_DOCROOT" ]] && rsync -ae "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/exclude_list.txt" --exclude="/$(basename $DOCUMENT_ROOT)" "$SSHUSER@$SSHHOST:$SOURCE_DIRECTORY" "$HOME" >/dev/null &
  else
    rsync -ave "ssh -qi $SSH_PRIVKEY -p $SSHPORT" --exclude-from="$HOME/tmp/exclude_list.txt" "$SSHUSER@$SSHHOST:$SOURCE_DIRECTORY" "$DESTINATION_DIRECTORY" | pv -cli 0.1 -N"Files Transferred" >/dev/null &
  fi
}

transferDatabase() {
  export MYSQL_PWD="$LOCAL_DBPASS"
  ssh -qi "$SSH_PRIVKEY" -p "$SSHPORT" "$SSHUSER@$SSHHOST" "export MYSQL_PWD='$REMOTE_DBPASS' && mysqldump --single-transaction -u $REMOTE_DBUSER $REMOTE_DBNAME" | pv -Wci 0.1 -N"Database Transfer" | sed 's/\sDEFINER=`[^`]*`@`[^`]*`//g' | mysql -u "$LOCAL_DBNAME" "$LOCAL_DBNAME" &
}

updateLocalConfig() {
  if [[ "$DOCUMENT_ROOT" ]]; then
    REMOTE_DBPASS=$(sed -E 's/(\W)/\\\1/g' <<< $REMOTE_DBPASS)
    LOCAL_DBPASS=$(sed -E 's/(\W)/\\\1/g' <<< $LOCAL_DBPASS)

    [[ "$CONFIG_FILE" == 'env.php' ]] && DESTINATION_DIRECTORY="$DESTINATION_DIRECTORY/app/etc"

    sed -i -E "s/\b$REMOTE_DBNAME\b/$LOCAL_DBNAME/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
    sed -i -E "s/\b$REMOTE_DBUSER\b/$LOCAL_DBNAME/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
    sed -i -E "s/\b$REMOTE_DBHOST\b/$LOCAL_DBHOST/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
    perl -pi -E "s/$REMOTE_DBPASS/$LOCAL_DBPASS/g" $DESTINATION_DIRECTORY/$CONFIG_FILE 2>/dev/null
  else
    printf "\033[1;33mWarning:\033[0m Manual change of config file is needed if it exists\n" >&2
    return 1
  fi
}

removeEnvPathSBO() {
  [[ $CONFIG_FILE != 'wp-config.php' ]] && return 1
  [[ ! $TABLE_PREFIX ]] && TABLE_PREFIX=$(awk -F'[\042\047]' '/table_prefix/ {print $2}' $DESTINATION_DIRECTORY/$CONFIG_FILE)
  mysql -u "$LOCAL_DBNAME" "$LOCAL_DBNAME" -se "UPDATE ${TABLE_PREFIX}options SET option_value = '' WHERE option_name = 'servebolt_env_file_path'" 2>/dev/null
}

# ====== MAIN ======= #

mkdir -p "$HOME/tmp"
tr ' ' '\n' <<< "${EXCLUDE_LIST[@]}" > "$HOME/tmp/exclude_list.txt"
tr ' ' '\n' <<< "${CUSTOM_EXCLUDE_LIST[@]}" > "$HOME/tmp/custom_exclude_list.txt"

getConfigFile
[[ ! "$NODB" ]] && parseConfig
[[ ! "$NODB" ]] && checkRemoteDatabaseConnection
[[ ! "$NODB" ]] && setLocalDBPassword
[[ ! "$NODB" ]] && checkLocalDatabaseConnection
checkDocumentRoot
echo

printf "\033[1;32mDoing Transfer...\033[0m\n"
tput civis
transferFiles
sleep .1
[[ ! "$NODB" ]] && transferDatabase
wait
tput cnorm

updateLocalConfig
[[ ! "$NODB" ]] && removeEnvPathSBO
printf "\033[1;32mDone!\033[0m"
tput bel
exit 0

